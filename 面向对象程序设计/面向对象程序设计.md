[toc] 

## 基类中的成员函数的分类

- 一、基类希望其派生类进行覆盖的函数**（virtual）**
- 二、基类希望派生类**直接继承**而**不要改变**的函数

## override关键字

- **override**出现的意义
  - 如果派生类定义了一个**与**基类中虚函数的**名字相同**但是**形参列表不同**，这是合法的行为，且编译器将认为新定义的这个函数与基类中**原有的函数**是**相互独立**的。
  - 就实际编程习惯而言这种声明往往发生了错误，程序猿的本意是想**覆盖基类中的虚函数**，但是一不小心把形参列表弄错了，故可以利用**C++11**的新标准，添加`override`来显式你的覆盖意图和检查是否与基类的形参列表相同

- 显式的注明派生类将使用哪个成员函数**改写成**基类的虚函数
- 是**在派生类中使用**，允许派生类显示的注明它将使用哪个**成员函数**改写**基类的虚函数**

## 声明成员函数为virtual

- `virtual`只能出现在**类内部**的声明语句之前而不能用于**类外部**的函数定义。
- 如果基类把一个函数声明成虚函数，则该函数在派生类中**隐式**的也是**虚函数**
- 如果成员函数没有被声明为虚函数，则其解析过程发生在编译时而非运行时
- 派生类如果没有覆盖其基类的某个虚函数，则该函数的行为类似于其他的普通成员，会直接继承其在基类中的版本

## 基类中成员的访问说明符

- `public`
  - 派生类可以访问，其他类也可以访问
- `protected`
  - 派生类可以访问，其他类不可以访问
- `private`
  - 派生类和其他类都不可以访问

## 派生列表中的访问说明符

![clip_image002](image\clip_image002.png)

- 说明
  - 继承访问说明符就代表在派生类中会不会改变基类的权限
  
- 如果在`protected`或者`private`继承中要保持原来的权限则可以使用`using`

  - ```c++
    class Base{
    public:
        size_t size() const { return n; }
    protected:
        size_t n;
    };
    class Derived : private Base{
    public:
        using Base::size;  // 使size的权限放在public中
    protected:
        using Base::n;  // 使n的权限放在protected中
    }
    ```

  - 例子：

    - ```c++
      struct A {
      public:
      	int pub_a;
      private:
      	int pri_a;
      protected:
      	int pro_a;
      };
      struct B :protected A{
      
      };
      struct C :public B {
      
      };
      
      int main() {
      	B b;
      	b.pub_a;
      	system("pause");
      }
      ```

    - 自己折腾一下就会了


## 派生类向基类的类型转换（“向上转型”）

- 派生类包含多个组成部分
  - 自己定义的（非静态）成员的子对象
  - 一个（或者多个）与该派生类继承的基类对应的子对象
- 纵观第一条，基类引用指向派生类其实就是指向派生类中基类的部分
  - ![clip_image002](image\基类指针指向派生类.png)

## 派生类向基类转换的可访问性（“向上转型”的可行性）

![派生类向基类转换的可访问性](.\image\派生类向基类转换的可访问性.png)

- 只有当`D`**公有**地继承`B`时，**用户代码**(main函数直接的代码)才能使用派生类向基类的转换（"向上转型"）**见上图main函数**
- 不论`D`以什么方式继承`B`，`D`**的成员函数和友元**都能使用派生类向基类的转换  **见上图test函数**
- 如果`D`继承`B`的方式是公有的或者受保护的，则`D`的**派生类的成员和友元**可以使用`D`向`B`的类型转换  **见上图p函数**

- **总结**
  - 假设`D`继承自`B`，
    - 用户代码想使用`B* b = D();`，那么继承关系只能是`public`，
    - `B`的**友元**或者是**成员函数**想使用`B* b = D();`，任何一种继承关系都可以使用
    - `B`的**派生类**的**友元**和**成员函数**想使用`B* b = D();`，则其D与B的继承关系只能是`public`或者`protected`

## 派生类构造函数

- 派生类的**构造函数**通过**初始化列表**来**调用基类的构造函数**初始化基类

## 派生类的声明不能带有派生列表

- 派生类的声明

  - ```c++
    class Bulk_quote : public Quote;  // 错误
    class Bulk_quote;                 // 正确  声明派生类的正确方式
    ```

  - **注意：**上述错误被称为派生列表。

    - **派生列表**以及与**定义有关的其他细节**必须与**类的主体**一起出现

## 被用作基类的类

- 如果我们想将某个类作为基类，则该类必须已经定义而非仅仅声明

## 防止继承的发生

### final关键字

- `class Last final { };`
- 还可以把某个函数声明为`final`，这样一来任何尝试覆盖该函数的操作都将引发错误。

## 静态类型与动态类型

在**P527**`print_total(ostream &os, const Quote &item, size_t n)`函数中有一个形参 `const Quote &item`、这个**形参的类型`Quote&`就是静态类型**，他的**动态类型依赖于`item`绑定的实参**，动态类型知道在运行时调用该函数时才会知道。

- **注意：**如果表达式**既不是引用也不是指针**，则它的**动**态类型永远与**静**态类型**一致**。
  
  - 例如，`Quote`类型的变量永远是一个`Quote`对象，无论如何都不能改变该变量对应的类型
  
- 例子：

  - `A`是基类、`B`是派生类，`B`显式的重写了`A`类的`print`函数

  - ```c++
    struct A {
    	A() {
    		cout << "构造函数A" << endl;
    	}
    	~A() {
    		cout << "析构函数A" << endl;
    	}
    	virtual void print() const {
    		cout << "打印A" << endl;
    	};
    	int a;  // a类特有成员
    };
    struct B :public A{
    	B() {
    		cout << "构造函数B" << endl;
    	}
    	~B() {
    		cout << "析构函数B" << endl;
    		
    	}
    	void print() const override{
    		cout << "打印B" << endl;
    	}
    	int b;  // b类特有成员
    };
    ```

  - 在main函数中书写一下测试

    - ```c++
      B b;
      A a1 = b;  	 // 静态类型
      A &a2 = b;	 // 动态类型
      A *a3 = &b;	 // 动态类型
      a1.print();  // 打印A的print
      a2.print();  // 打印B的print
      a3.print();  // 打印B的print
      ```


### 不允许从基类转型到派生类

- 这里的基类的类型指的是**静态类型**的类型

- ```c++
  B b1;
  A *a = &b1;
  B *b2 = a;  // 编译错误、a的静态类型是A，不允许从基类转型到派生类
  ```

#### 解决办法(dynamic_cast)

- ```c++
  B b;
  A *a = &b;
  B *b2 = dynamic_cast<B*>(a);  // 利用dynamic_cast强转静态类型为A*的为B*
  b2->b;  // 特别的 从a转型够来后还可以访问B中的特有元素也可以访问a类的特有元素
  b2->a;
  b2->print();
  ```

## 类java的向上转型语法在c++中是什么意思

### `A a = B();`

- 当我们通过一个普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。**并不会存在多态**
- 上述代码如果执行`a.print()`，则会执行`A`的`print`不会执行`B`的`print`

## c++为什么可以向上转型（额。。借用java的术语）

- 之所以存在派生类向基类的类型转换是**因为每个派生类对象都包含一个基类部分**
- **注意**
  - 当我们用一个派生类对象为一个基类对象初始化或者赋值时，只有该派生类对象中的基类部分会保留，他的派生类部分将被忽略，但不是消失，利用`dynamic_cast`**”向下转型“**后可以访问派生类的部分

## 虚函数

- 一个派生类一旦覆盖了某个继承而来的虚函数，则它的**形参类型**必须与被他覆盖的基类函数**一致**，同样，派生类中的返回类型也必须与基类函数匹配。

  - 例外：

    - ##### `B`是基类，`D`是派生类，B的虚函数可以返回`B*`，`D`的虚函数可以返回`D*` ，悬念**P561**

- 当使用基类的引用或者指针调用一个虚成员函数时会执行动态绑定。此时我们只有直到运行时才能知道到底调用了哪个版本的虚函数，所以**所有虚函数必须有定义**

- 一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数（隐式`virtual`），可以用`final`在某一层终止下面的派生类覆盖

- 对**非虚函数**的调用在**编译时绑定**，通过**对象**（非指针和引用）进行的**函数调用**（虚函数或者非虚函数）也在**编译时绑定**

## c++语言如何支持多态

### 引用或指针的静态类型与动态类型不同。

## 虚函数与默认实参

- 如果虚函数使用默认实参（也可以说是设置了默认参数在调用时候没有传参），则基类和派生类中定义的默认实参最好**一致**

  - **解释：**如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。

    - 例子：`A`与`B` 的`print` 函数都添加一个默认参数`int` 在`A`中是2，在`B`中是1

    - ```c++
      virtual void print(int a = 2) const {
          cout << "打印A" << a <<endl;
      };
      
      void print(int a = 1) const override{
      	cout << "打印B" <<a<< endl;
      }
      ```

    - 此时调用

      - ```c++
        B b;
        A *a = &b;
        a->print();  // 将打印 《打印B2》
        ```

      - 由于动态类型与静态类型不一致，调用的函数是B中的函数，但是传入的参数是A中的默认参数

## 回避虚函数机制

- 使用作用于来强行执行某一指定版本的虚函数

  - ```c++
    B b;
    A *a = &b;
    a->A::print();
    ```

- 动态绑定之后调用**某个指定的**虚函数版本

## 纯虚函数`P540`

- 在**类的内部**的虚函数声明语句后加 =0

  - `double net_price(size_t) const = 0;`

- 纯虚函数也可以定义，但是只能在类的外部，如果想要使用要**用作用域**

  - ```c++
    class A {
    public:
    	virtual void print() = 0;
    	int a;
    };
    class B : public A{
    public:
    	int b;
    	void print() override {
    		cout << "b" << endl;
    	}
    };
    void A::print() {
    	cout << "a" << endl;
    }
    ```

  - ```c++
    int main() {
    	B b;
    	A *a = &b;
    	B *b2 = dynamic_cast<B*>(a);
        // 两种使用A中纯虚函数的方法
        a->A::print();	 // 打印a
        b2->A::print();  // 打印a
    	system("pause");
    }
    ```

- 不能直接定义含有纯虚函数的类的对象

## 抽象基类

- 含有（或者**未经覆盖**直接继承）**纯虚函数**的类是**抽象基类**
- 不能**直接创建**一个抽象基类的对象，只能通过其**非抽象基类**的派生类来构造

## protected详解

- 一个类使用`protected`关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。

  - 与`private`类似，受保护的成员对于类的用户来说是不可访问的。

  - 与`public`类似，受保护的成员对于**派生类的成员和友元**来说是可访问的

  - 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问权限

    - 对于这样两个类

      ```c++
      struct C {
      protected:
      	int c;
      };
      struct B : C{
          friend void print();
          friend void print(C &);
      protected:
      	int b;
      };
      
      void print() {
      	B b;
      	cout<<b.b; // 可访问
          cout<<b.c; // 可访问
      }
      void print(C &c){
          cout<<c.c; //不可访问
      }
      ```

    - 执行下列测试

      ```c++
      int main(){
      	B b;
      	cout<<b.b;  // 报错，不可访问
      	cout<<b.c;  // 报错，不可访问   
      }
      ```

    - 结果，只有友元与成员函数可以访问

## 友元与继承

- 在一个类中声明友元类

  - ```c++
    class Base{
       	friend class Pal;
    public:
        void pub_mem();
    private:
        int prot_mem;
    protected:
        char priv_mem;
    }
    // Sneaky类继承自Base
    class Pal{
    public:
        int f(Base b){ return b.prot_mem; }
        int f2(Sneaky s){ return s.j; }  // 不可访问
        int f3(Sneaky s){ return s.prot_mem; }  // 可访问
    }
    ```

## struct与class中继承的默认访问说明符

- `struct B : A {};`  —**等价于**—>`struct B : public A {};`
- `class B : A {};`—**等价于**—>`class B : private A {};`

## 静态类型决定能使用哪些成员

```c++
Bulk_quote bulk;
Bulk_quote *bulkP = &bulk;  // 静态类型与动态类型一致
Quote *item = &bulk;		// 静态类型与动态类型不一致
bulkP->discount_policy();	// 正确：bulkP的类型是Bulk_quote*  意味着discount_policy的搜索是从Bulk_quote开始的
itemP->discount_policy();	//错误：itemP的类型是Quote*  意味着discount_policy的搜索是从Quote开始的，向上找不到discount_policy()
```

## 函数调用的解析过程

假设调用`P->mem()`，则依次执行以下`4`个步骤

- 确定`P`的静态类型`st`
- 然后在`st`类中查找`mem`，如果找不到，则往其基类中找，如果仍找不到则编译报错
- 如果找到了`mem`，就进行常规类型检查，查看调用是否合法

- 如果调用合法，则编译器将根据调用的是否是虚函数和而产生不同的代码

## 派生类与基类同名的函数并不叫重写

- 派生类只有重写同名的虚函数才叫重写，这样才能在动态类型中实时确定函数

- 如果重写的不是虚函数，则只是隐藏了基类中同名的函数，在**"向上转型"**的时候不会动态调用，只会调用静态类型对应的函数

  - 并且派生类在调用同名不同参数列表的基类函数时会报错，因为其被隐藏了

    - ```c++
      struct Base{
          int memfcn();
      };
      struct Derived : Base{
          int memfcn(int);
      };
      Derived d;
      Base b;
      b.memfcn();  	// 调用Base::memfcn 
      d.memfcn(10); 	// 调用Derived::memfcn
      d.memfcn();  	// 错误:参数列表为空的memfcn被隐藏了
      d.Base::memfcn();// 正确:调用Base::memfcn
      ```

    - 原理：
      - 根据上一条 **函数调用的解析过程** 可知，名字查找优先于类型检查，编译器首先在`Derived`中查找名字`memfcn`；因为`Derived`确实定义了一个名为`memfcn`的成员，所以查找过程终止。然后就是类型检查，空参列表与有一个`int`的参数不符，所以该调用语句是错误的，这也就是**为什么基类的虚函数与派生类的虚函数必须有相同的形参列表了**

## 虚析构函数

- 如果我们定义基类的析构函数为虚析构函数，则无论其派生类使用合成的析构函数还是定义自己的析构函数，都将是虚析构函数

- delete一个动态分配的对象指针时会执行析构函数

  - ```c++
    Quote *itemP = new Bulk_quote;
    delete itemp;
    ```

- 只有当基类的析构函数是虚函数，就能确保当我们delete基类指针时将运行正确的析构函数版本（**动态绑定**），也就是上述代码会调用`Bulk_quote`的析构函数

- 如果基类的析构函数不是虚函数，则上述代码将产生未定义的行为

## 派生类中删除的拷贝控制与基类的关系

- **番外：**一旦一个类中定义了其他构造函数，则该类不会自动定义合成的默认构造函数
- 如果基类中的**默认构造函数**、**拷贝构造函数**、**拷贝赋值运算符**或**析构函数**是**被删除**或者是**不可访问**的，则派生类中对应的成员将是被删除的。
  - 编译器不能使用**基类成员**来执行**派生类对象基类部分**的构造、赋值、销毁操作
- 如果在基类中有一**个不可访问或删除掉**的**析构**函数，则派生类中合成的**默认和拷贝**构造函数是**删除**的
  - 因为编译器无法销毁**派生类对象的基类部分**
- 如果基类中移动操作是**删除的或者不可访问**的，那么派生类中该函数是被**删除**的。
  - **派生类对象的基类部分**不可移动

## 总结各个构造函数会自己合成的情况

- **默认构造函数**
  - 一旦一个类中定义了其他构造函数，则该类不会自动定义合成的默认构造函数
- **合成拷贝构造函数**`P440`
  - 如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数
- **合成拷贝赋值运算符**`P444`
  - 如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符
- **合成移动操作**
  - 当一个类没有定义任何自己版本的拷贝控制成员，且每个非`static`数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符

## 移动操作与继承

- 如果如果基类定义了自己的移动操作，那么他必须同时显示的定义拷贝操作

## 派生类的拷贝\移动、赋值运算符需要显式的初始化基类

- 拷贝/移动构造（需要初始化列表）
  - `D(const D& d) : Base(d) {}`
  - `D(D&& d) : Base(std::move(d)) {}`

- 拷贝/移动赋值运算符（在函数体中体现）

  - ```c++
    D &D::operaor=(const D &rhs){
        Base::operator=(rhs);
        // 派生类的相关拷贝赋值操作
        return *this;
    }
    ```

## 在构造函数和析构函数中调用虚函数的注意事项

在构造一个对象的时候，执行基类操作的时候（基类的构造函数与析构函数）该对象（派生类对象）是处于未完成的状态，所以当基类执行构造函数时，他要用到的派生类成员尚未初始化，如果我们允许这样的访问，则程序很可能会崩溃

## 继承的构造函数

- 派生类继承基类构造函数的方式是提供一条注明了直接基类名的`using`声明语句。

  - ```c++
    // 可以重新定义Bulk_quote类，让其构造函数继承直接基类Disc_quote的构造函数
    class Bulk_quote : public Disc_quote{
    public:
    	using Disc_quote::Disc_quote;    
    }
    ```

  - 这样一来，对于`Disc_quote`的每个构造函数，编译器都在`Bulk_quote`中生成一个**形参列表完全相同**的构造函数

  - 例如上述`using`语句等价于

    - ```c++
      Bulk_quote(const string& book, double price,
                size_t qty, double disc):
      	Disc_quote(book, price, qty, disc){ }
      ```

    - 
