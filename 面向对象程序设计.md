## 基类中的成员函数的分类

- 一、基类希望其派生类进行覆盖的函数**（virtual）**
- 二、基类希望派生类**直接继承**而**不要改变**的函数

## override关键字

- **override**出现的意义
  - 如果派生类定义了一个**与**基类中虚函数的**名字相同**但是**形参列表不同**，这是合法的行为，且编译器将认为新定义的这个函数与基类中**原有的函数**是**相互独立**的。
  - 就实际编程习惯而言这种声明往往发生了错误，程序猿的本意是想**覆盖基类中的虚函数**，但是一不小心把形参列表弄错了，故可以利用**C++11**的新标准，添加`override`来显式你的覆盖意图和检查是否与基类的形参列表相同

- 显式的注明派生类将使用哪个成员函数**改写成**基类的虚函数
- 是在**派生类**中使用，允许派生类显示的注明它将使用哪个**成员函数**改写**基类的虚函数**

## 声明成员函数为virtual

- `virtual`只能出现在**类内部**的声明语句之前而不能用于**类外部**的函数定义。
- 如果基类把一个函数声明成虚函数，则该函数在派生类中**隐式**的也是**虚函数**
- 如果成员函数没有被声明为虚函数，则其解析过程发生在编译时而非运行时
- 派生类如果没有覆盖其基类的某个虚函数，则该函数的行为类似于其他的普通成员，会直接继承其在基类中的版本

## 基类中权限关键字的描述

- `public`
  - 派生类可以访问，其他类也可以访问
- `protected`
  - 派生类可以访问，其他类不可以访问
- `private`
  - 派生类和其他类都不可以访问

## 继承时候的关键字

![clip_image002](image\clip_image002.png)

- 说明
  - 继承访问说明符就代表在派生类中会不会改变基类的权限

## 派生类向基类的类型转换

- 派生类包含多个组成部分
  - 自己定义的（非静态）成员的子对象
  - 一个（或者多个）与该派生类继承的基类对应的子对象
- 纵观第一条，基类引用指向派生类其实就是指向派生类中基类的部分
  - ![clip_image002](image\基类指针指向派生类.png)

## 派生类构造函数

- 派生类的构造函数通过初始化列表来调用基类的构造函数初始化基类

## 派生类的声明

- 派生类的声明

  - ```c++
    class Bulk_quote : public Quote;  // 错误
    class Bulk_quote;                 // 正确  声明派生类的正确方式
    ```

  - **注意：**上述错误被称为派生列表。

    - 派生列表以及与定义有关的其他细节必须与类的主体一起出现

## 被用作基类的类

- 如果我们想将某个类作为基类，则该类必须已经定义而非仅仅声明

## 防止继承的发生

### **final关键字**

- `class Last final { };`

## 静态类型与动态类型

在**P527**`print_total(ostream &os, const Quote &item, size_t n)`函数中有一个形参 `const Quote &item`、这个**形参的类型`Quote&`就是静态类型**，他的**动态类型依赖于`item`绑定的实参**，动态类型知道在运行时调用该函数时才会知道。

- **注意：**如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。
  
  - 例如，`Quote`类型的变量永远是一个`Quote`对象，无论如何都不能改变该变量对应的类型
  
- 例子：

  - `A`是基类、`B`是派生类，`B`显式的重写了`A`类的`print`函数

  - ```c++
    struct A {
    	A() {
    		cout << "构造函数A" << endl;
    	}
    	~A() {
    		cout << "析构函数A" << endl;
    	}
    	virtual void print() const {
    		cout << "打印A" << endl;
    	};
    	int a;  // a类特有成员
    };
    struct B :public A{
    	B() {
    		cout << "构造函数B" << endl;
    	}
    	~B() {
    		cout << "析构函数B" << endl;
    		
    	}
    	void print() const override{
    		cout << "打印B" << endl;
    	}
    	int b;  // b类特有成员
    };
    ```

  - 在main函数中书写一下测试

    - ```c++
      B b;
      A a1 = b;  	 // 静态类型
      A &a2 = b;	 // 动态类型
      A *a3 = &b;	 // 动态类型
      a1.print();  // 打印A的print
      a2.print();  // 打印B的print
      a3.print();  // 打印B的print
      ```


### 不允许从基类转型到派生类

- 这里的基类的类型指的是**静态类型**的类型

- ```c++
  B b1;
  A *a = &b1;
  B *b2 = a;  // 编译错误、a的静态类型是A，不允许从基类转型到派生类
  ```

#### 解决办法(dynamic_cast)

- ```c++
  B b;
  A *a = &b;
  B *b2 = dynamic_cast<B*>(a);  // 利用dynamic_cast强转静态类型为A*的为B*
  b2->b;  // 特别的 从a转型够来后还可以访问B中的特有元素也可以访问a类的特有元素
  b2->a;
  b2->print();
  ```

## 类java的向上转型在c++中是什么意思

### `A a = B();`

- 当我们通过一个普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。**并不会存在多态**
- 上述代码如果执行`a.print()`，则会执行`A`的`print`不会执行`B`的`print`

## c++为什么可以向上转型（额。。借用java的术语）

- 之所以存在派生类向基类的类型转换是**因为每个派生类对象都包含一个基类部分**
- **注意**
  - 当我们用一个派生类对象为一个基类对象初始化或者赋值时，只有该派生类对象中的基类部分会保留，他的派生类部分将被忽略

## 虚函数

- 一个派生类一旦覆盖了某个继承而来的虚函数，则它的**形参类型**必须与被他覆盖的基类函数**一致**，同样，派生类中的返回类型也必须与基类函数匹配。

  - 例外：

    - ##### `B`是基类，`D`是派生类，B的虚函数可以返回`B*`，`D`的虚函数可以返回`D*`  悬念**P561**

- 当使用基类的引用或者指针调用一个虚成员函数时会执行动态绑定。此时我们只有直到运行时才能知道到底调用了哪个版本的虚函数，所以**所有虚函数必须有定义**

- 一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数（隐式`virtual`）

- 对**非虚函数**的调用在**编译时绑定**，通过**对象**（非指针和引用）进行的**函数调用**（虚函数或者非虚函数）也在**编译时绑定**

## c++语言如何支持多态

### 引用或指针的静态类型与动态类型不同。

