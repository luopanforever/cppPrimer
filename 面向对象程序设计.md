[toc] 

## 基类中的成员函数的分类

- 一、基类希望其派生类进行覆盖的函数**（virtual）**
- 二、基类希望派生类**直接继承**而**不要改变**的函数

## override关键字

- **override**出现的意义
  - 如果派生类定义了一个**与**基类中虚函数的**名字相同**但是**形参列表不同**，这是合法的行为，且编译器将认为新定义的这个函数与基类中**原有的函数**是**相互独立**的。
  - 就实际编程习惯而言这种声明往往发生了错误，程序猿的本意是想**覆盖基类中的虚函数**，但是一不小心把形参列表弄错了，故可以利用**C++11**的新标准，添加`override`来显式你的覆盖意图和检查是否与基类的形参列表相同

- 显式的注明派生类将使用哪个成员函数**改写成**基类的虚函数
- 是**在派生类中使用**，允许派生类显示的注明它将使用哪个**成员函数**改写**基类的虚函数**

## 声明成员函数为virtual

- `virtual`只能出现在**类内部**的声明语句之前而不能用于**类外部**的函数定义。
- 如果基类把一个函数声明成虚函数，则该函数在派生类中**隐式**的也是**虚函数**
- 如果成员函数没有被声明为虚函数，则其解析过程发生在编译时而非运行时
- 派生类如果没有覆盖其基类的某个虚函数，则该函数的行为类似于其他的普通成员，会直接继承其在基类中的版本

## 基类中成员的访问说明符

- `public`
  - 派生类可以访问，其他类也可以访问
- `protected`
  - 派生类可以访问，其他类不可以访问
- `private`
  - 派生类和其他类都不可以访问

## 派生列表中的访问说明符

![clip_image002](image\clip_image002.png)

- 说明
  - 继承访问说明符就代表在派生类中会不会改变基类的权限
  
- 如果在`protected`或者`private`继承中要保持原来的权限则可以使用`using`

  - ```c++
    class Base{
    public:
        size_t size() const { return n; }
    protected:
        size_t n;
    };
    class Derived : private Base{
    public:
        using Base::size;  // 使size的权限放在public中
    protected:
        using Base::n;  // 使n的权限放在protected中
    }
    ```

  - 例子：

    - ```c++
      struct A {
      public:
      	int pub_a;
      private:
      	int pri_a;
      protected:
      	int pro_a;
      };
      struct B :protected A{
      
      };
      struct C :public B {
      
      };
      
      int main() {
      	B b;
      	b.pub_a;
      	system("pause");
      }
      ```

    - 自己折腾一下就会了


## 派生类向基类的类型转换（“向上转型”）

- 派生类包含多个组成部分
  - 自己定义的（非静态）成员的子对象
  - 一个（或者多个）与该派生类继承的基类对应的子对象
- 纵观第一条，基类引用指向派生类其实就是指向派生类中基类的部分
  - ![clip_image002](image\基类指针指向派生类.png)

## 派生类向基类转换的可访问性（“向上转型”的可行性）

![派生类向基类转换的可访问性](.\image\派生类向基类转换的可访问性.png)

- 只有当`D`**公有**地继承`B`时，**用户代码**(main函数直接的代码)才能使用派生类向基类的转换（"向上转型"）**见上图main函数**
- 不论`D`以什么方式继承`B`，`D`**的成员函数和友元**都能使用派生类向基类的转换  **见上图test函数**
- 如果`D`继承`B`的方式是公有的或者受保护的，则`D`的**派生类的成员和友元**可以使用`D`向`B`的类型转换  **见上图p函数**

- **总结**
  - 假设`D`继承自`B`，
    - 用户代码想使用`B* b = D();`，那么继承关系只能是`public`，
    - `B`的**友元**或者是**成员函数**想使用`B* b = D();`，任何一种继承关系都可以使用
    - `B`的**派生类**的**友元**和**成员函数**想使用`B* b = D();`，则其D与B的继承关系只能是`public`或者`protected`

## 派生类构造函数

- 派生类的**构造函数**通过**初始化列表**来**调用基类的构造函数**初始化基类

## 派生类的声明不能带有派生列表

- 派生类的声明

  - ```c++
    class Bulk_quote : public Quote;  // 错误
    class Bulk_quote;                 // 正确  声明派生类的正确方式
    ```

  - **注意：**上述错误被称为派生列表。

    - **派生列表**以及与**定义有关的其他细节**必须与**类的主体**一起出现

## 被用作基类的类

- 如果我们想将某个类作为基类，则该类必须已经定义而非仅仅声明

## 防止继承的发生

### final关键字

- `class Last final { };`
- 还可以把某个函数声明为`final`，这样一来任何尝试覆盖该函数的操作都将引发错误。

## 静态类型与动态类型

在**P527**`print_total(ostream &os, const Quote &item, size_t n)`函数中有一个形参 `const Quote &item`、这个**形参的类型`Quote&`就是静态类型**，他的**动态类型依赖于`item`绑定的实参**，动态类型知道在运行时调用该函数时才会知道。

- **注意：**如果表达式**既不是引用也不是指针**，则它的**动**态类型永远与**静**态类型**一致**。
  
  - 例如，`Quote`类型的变量永远是一个`Quote`对象，无论如何都不能改变该变量对应的类型
  
- 例子：

  - `A`是基类、`B`是派生类，`B`显式的重写了`A`类的`print`函数

  - ```c++
    struct A {
    	A() {
    		cout << "构造函数A" << endl;
    	}
    	~A() {
    		cout << "析构函数A" << endl;
    	}
    	virtual void print() const {
    		cout << "打印A" << endl;
    	};
    	int a;  // a类特有成员
    };
    struct B :public A{
    	B() {
    		cout << "构造函数B" << endl;
    	}
    	~B() {
    		cout << "析构函数B" << endl;
    		
    	}
    	void print() const override{
    		cout << "打印B" << endl;
    	}
    	int b;  // b类特有成员
    };
    ```

  - 在main函数中书写一下测试

    - ```c++
      B b;
      A a1 = b;  	 // 静态类型
      A &a2 = b;	 // 动态类型
      A *a3 = &b;	 // 动态类型
      a1.print();  // 打印A的print
      a2.print();  // 打印B的print
      a3.print();  // 打印B的print
      ```


### 不允许从基类转型到派生类

- 这里的基类的类型指的是**静态类型**的类型

- ```c++
  B b1;
  A *a = &b1;
  B *b2 = a;  // 编译错误、a的静态类型是A，不允许从基类转型到派生类
  ```

#### 解决办法(dynamic_cast)

- ```c++
  B b;
  A *a = &b;
  B *b2 = dynamic_cast<B*>(a);  // 利用dynamic_cast强转静态类型为A*的为B*
  b2->b;  // 特别的 从a转型够来后还可以访问B中的特有元素也可以访问a类的特有元素
  b2->a;
  b2->print();
  ```

## 类java的向上转型语法在c++中是什么意思

### `A a = B();`

- 当我们通过一个普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。**并不会存在多态**
- 上述代码如果执行`a.print()`，则会执行`A`的`print`不会执行`B`的`print`

## c++为什么可以向上转型（额。。借用java的术语）

- 之所以存在派生类向基类的类型转换是**因为每个派生类对象都包含一个基类部分**
- **注意**
  - 当我们用一个派生类对象为一个基类对象初始化或者赋值时，只有该派生类对象中的基类部分会保留，他的派生类部分将被忽略，但不是消失，利用`dynamic_cast`**”向下转型“**后可以访问派生类的部分

## 虚函数

- 一个派生类一旦覆盖了某个继承而来的虚函数，则它的**形参类型**必须与被他覆盖的基类函数**一致**，同样，派生类中的返回类型也必须与基类函数匹配。

  - 例外：

    - ##### `B`是基类，`D`是派生类，B的虚函数可以返回`B*`，`D`的虚函数可以返回`D*` ，悬念**P561**

- 当使用基类的引用或者指针调用一个虚成员函数时会执行动态绑定。此时我们只有直到运行时才能知道到底调用了哪个版本的虚函数，所以**所有虚函数必须有定义**

- 一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数（隐式`virtual`），可以用`final`在某一层终止下面的派生类覆盖

- 对**非虚函数**的调用在**编译时绑定**，通过**对象**（非指针和引用）进行的**函数调用**（虚函数或者非虚函数）也在**编译时绑定**

## c++语言如何支持多态

### 引用或指针的静态类型与动态类型不同。

## 虚函数与默认实参

- 如果虚函数使用默认实参（也可以说是设置了默认参数在调用时候没有传参），则基类和派生类中定义的默认实参最好**一致**

  - **解释：**如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。

    - 例子：`A`与`B` 的`print` 函数都添加一个默认参数`int` 在`A`中是2，在`B`中是1

    - ```c++
      virtual void print(int a = 2) const {
          cout << "打印A" << a <<endl;
      };
      
      void print(int a = 1) const override{
      	cout << "打印B" <<a<< endl;
      }
      ```

    - 此时调用

      - ```c++
        B b;
        A *a = &b;
        a->print();  // 将打印 《打印B2》
        ```

      - 由于动态类型与静态类型不一致，调用的函数是B中的函数，但是传入的参数是A中的默认参数

## 回避虚函数机制

- 使用作用于来强行执行某一指定版本的虚函数

  - ```c++
    B b;
    A *a = &b;
    a->A::print();
    ```

## 纯虚函数P540

- 在**类的内部**的虚函数声明语句后加 =0

  - `double net_price(size_t) const = 0;`

- 纯虚函数也可以定义，但是只能在类的外部，如果想要使用要用作用域

  - ```c++
    class A {
    public:
    	virtual void print() = 0;
    	int a;
    };
    class B : public A{
    public:
    	int b;
    	void print() override {
    		cout << "b" << endl;
    	}
    };
    void A::print() {
    	cout << "a" << endl;
    }
    ```

  - ```c++
    int main() {
    	B b;
    	A *a = &b;
    	B *b2 = dynamic_cast<B*>(a);
        b2->A::print();  // 打印a
    	a->A::print();	 // 打印b
    	system("pause");
    }
    ```

- 不能直接定义含有纯虚函数的类的对象

## 抽象基类

- 含有（或者**未经覆盖**直接继承）**纯虚函数**的类是**抽象基类**
- 不能**直接创建**一个抽象基类的对象，只能通过其**非抽象基类**的派生类来构造

## protected详解

- 一个类使用`protected`关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。

  - 与`private`类似，受保护的成员对于类的用户来说是不可访问的。

  - 与`public`类似，受保护的成员对于**派生类的成员和友元**来说是可访问的

  - 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问权限

    - 对于这样两个类

      ```c++
      struct C {
      protected:
      	int c;
      };
      struct B : C{
          friend void print();
          friend void print(C &);
      protected:
      	int b;
      };
      
      void print() {
      	B b;
      	cout<<b.b; // 可访问
          cout<<b.c; // 可访问
      }
      void print(C &c){
          cout<<c.c; //不可访问
      }
      ```

    - 执行下列测试

      ```c++
      int main(){
      	B b;
      	cout<<b.b;  // 报错，不可访问
      	cout<<b.c;  // 报错，不可访问   
      }
      ```

    - 结果，只有友元与成员函数可以访问

## 友元与继承

- 在一个类中声明友元类

  - ```c++
    class Base{
       	friend class Pal;
    public:
        void pub_mem();
    private:
        int prot_mem;
    protected:
        char priv_mem;
    }
    // Sneaky类继承自Base
    class Pal{
    public:
        int f(Base b){ return b.prot_mem; }
        int f2(Sneaky s){ return s.j; }  // 不可访问
        int f3(Sneaky s){ return s.prot_mem; }  // 可访问
    }
    ```

## struct与class中继承的默认访问说明符

- `struct B : A {};`  —**等价于**—>`struct B : public A {};`
- `class B : A {};`—**等价于**—>`class B : private A {};`
